# 우테코 정규표현식
우테코의 미션 '문자열 덧셈 계산기' 를 통해 정규표현식에 대해 알아본다.

# 정규표현식
문자열의 **검색, 치환, 추출** 을 목적으로 사용하는 형식 언어 이다.

패턴을 정의해 엔진이 입력 문자열을 스캔하며 해당 패턴과 일치하는 부분을 찾아낸다.

# 사용법
- 패턴의 시작 : `//`
- 패턴의 끝 : `\n`

- 변할 수 있는 값 : `.*`
	- `.` : Dot, 개행 문자를 제외한 모든 문자 하나
	- `*` : Asterisk, 앞의 요소가 0개 이상 반복 됨
	- `(.*)` :합쳐서 모든 문자가 0개 이상 온다, 아무 문자열이나 다 된다는 의미가 된다.

- 캐럿, 문자열의 시작 지점 : `^`

`^//(.*)\\n` : 문자열의 제일 앞에 `//` 가 온다면 `//` 와 `\n` 사이에 오는 문자 하나

- 메서드
- `replaceFirst("")` : 찾아낸 패턴을 파라미터로 대체
- `matcher.end()` : 패턴이 끝난 직후 위치의 인덱스

# 왜 이스케이프 문자가 두번 오나요?
`\n` 와 `\\n` 는 사실 결과만 놓고 보면 똑같다.
어째서 같을까?

## `\n` 의 경우
1. 소스 코드 : `String p = "\n";`
2. 자바 컴파일러 : 컴파일러는 이 문자열을 해석해서 '줄바꿈'(ASCII 10) 으로 해석, 교체한다
3. 메모리 : 실제 메모리에 '줄바꿈' 제어문자가 등록된다
4. 정규식 엔진 : 패턴에 '줄바꿈' 이 있음을 인지하고 입력값에서 줄바꿈을 찾는다

## `\\n` 의 경우
1. 소스 코드 : `String p = "\\n";`
2. 자바 컴파일러 : 컴파일러는 이스케이프 문자를 인식하고 뒤에 오는 이스케이프 문자를 이스케이프해준다. 최종적으로 `\` 라는 문자와 `n` 이라는 문자가 된다.
3. 메모리 : 실제 메모리에 `\` + `n` 이라는 진짜 문자가 등록된다.
4. 정규식 엔진 : `\` 와 `n` 이 들어온걸보고 이를 줄바꿈 기호로 인식해서 '줄바꿈' 을 찾는다

두 시나리오 모두 과정은 조금 달라지지만 결론적으로 정규식 엔진은 줄바꿈 기호를 찾으려고 한다.

>그렇다면 왜 `\\n` 을 쓸까?

정규식에는 `\d`, `\w` 패턴이 있다. 각각 숫자, 글자에 대응하는 패턴이다.

만약 `\d` 로 입력하면 자바 컴파일러는 `\d` 에 해당하는 이스케이프 리터럴이 없어서 컴파일 에러가 난다.
`\\d` 로 입력해야 뒤의 이스케이프 구문을 인식하고 `\` 문자와 `d` 문자로 처리한다.
비로소 정규식 엔진이 `\d` 가 들어왔음을 인지하고 숫자 패턴을 처리한다.

`\n` 는 우연히 자바 이스케이프 문자와 정규식의 특수 문자가 둘 다 줄바꿈을 의미하도록 겹쳐서 생긴 일이다.
즉, 원래대로라면 정규식 패턴을 표현하기 위해 `\\d` 등으로 이스케이프를 해줘야 정상적으로 인식된다.
따라서 `\n` 도 `\\n` 으로 관례적으로 작성해주는게 좋다.


# group() 메서드
정규식은 괄호로 묶여서 관리된다
`(pattern)-(pattern)-(pattern)`
1번 패턴 다음 하이픈 2번 패턴 다음 하이픈 3번 패턴
이런식
이 괄호 별로 우리가 찾고자하는 패턴에 접근할 수 있게 도와주는 메서드가 group 메서드다

- group(0) : 패턴에 잡힌 결과와 문자열 전체를 반환한다
- group(1) : 첫번째 괄호 부분의 패턴 검색 결과
- group(2) : 두번째 괄호 부분의 패턴 검색 결과
... 괄호 반복

# find(), matches() 메서드
문자열 안에 패턴이 존재하는지, 즉 부분 일치 검색 메서드다.
find()로 찾으면 스캔하다가 찾았을 경우 멈춘다. 반복 호출 로직을 짜면 그 다음으로 넘어가며 찾는다.

matches() 는 문자열 전체가 원하는 패턴과 완전하게 일치하는지 확인한다. 전체 일치 검증

우리 예제의 경우 find() 가 적합하다.

# Pattern.quote

정규식에는 특별한 명령 기능을 가진 문자열이 존재한다.
위에서 언급한 `\d` 같은것들.

'그냥 문자열을 의미하고 싶었지만' '정규식 특별 명령 기능' 과 동일한 문자열이어서 문자열이 아니라 특별 명령 기능으로 동작하는걸 방지하기 위해 quote 메서드가 존재한다.

예를 들어 `+` 는 정규식 엔진이 문자열로 인식하지 않고 '앞의 문자가 1개 이상 있다' 라는 의미가 된다.
내가 `+` 을 구분자로 의도하면 이건 문자열로 인식해야하기 때문에
Pattern.quote("+") 메서드를 실행시켜주면,
자바가 이 문자열을 `\Q+\E` 라는 문자열로 바꿔준다.
`\Q` : quote start
`\E` : quote end
즉 이 사이에 온 것은 그냥 문자열로 인식하라는 표시다.

# Collectors.joining("|")

정규표현식 파서를 만들기 위해 파이프 기호로 찾아낸 구분자를 묶는다.
정규식에서 "|" 는 OR 연산을 의미하게 된다.
",|:" 는 콤마와 콜론으로 자르라는 뜻이 된다.

quote 와 합쳐서, 내가 구분자로 인식한 문자열들을 정규식 기능으로 인지하지 말고 문자열로 인식하게 해서 OR 연산으로 묶어 구분자 regex 를 만들고 이를 split() 메서드에 전달해 쪼개도록 한다.

