# 스키마
- DB 의 구조(개체, 속성, 관계) 와 제약 조건에 대한 정의
- DB 의 메타 데이터라고 할 수 있다
- 사용자가 자료를 저장, 조회, 삭제, 변경 할 때 DBMS 는 자신이 생성한 데이터 베이스 스키마를 참조해 명령을 수행한다


# 데이터 모델링
- 현실 세계의 비즈니스 요구사항을 분석, DB 에 저장할 데이터 구조를 논리적으로 정의하는 과정

## Entity
- 저장하고자 하는 데이터의 대상
	- `Member` 회원, `Article` 게시글, `Order` 주문
	- 보통 명사로 표현 되고 DB 의 `Table` 로 구현된다

## Attribute
- 개체의 구체적인 정보 항목
	- `Member` 의 `id`, `name`, `email`
	- 테이블의 `Column` 으로 구현된다

## Relationship
- 개체와 개체 사이의 논리적인 연관성 
	- `Member` 가 여러 개의 `Article`  을 작성할 수 있다
	- 주로 `Foreign Key` 제약 조건으로 구현된다

# ERD, Entity - Relationship Diagram
- 개체 - 관계 다이어그램은 위에서 정의한 세 요소를 표준화된 표기법으로 시각화한 설계도이다
- 관계의 유형, `Cardinality` 를 정의하는게 핵심으로
	- 1:1, `Member` - `Member_Info`, 하나의 회원은 하나의 회원정보를 가짐
	- 1:N, `Member` - `Article`, 하나의 회원은 여러 게시글을 가질 수 있음
	- N:M, `Student` - `Course`, N개의 학생은 M개의 과목을 가질 수 있음
		- 관계형 데이터베이스는 N:M 관계를 직접 표현할 수 없다
		- 연결 테이블, `Junction Table` 혹은 매핑 테이블(수강신청 테이블)을 통해 표현한다

# 데이터베이스 정규화, Normalization
- 데이터의 중복을 최소화하고 무결성을 보장하는, 정해진 규칙에 따라 테이블을 분해 하는 체계적인 프로세스
- 정규화를 거치지 않으면 데이터 조작 (`INSERT`, `UPDATE`, `DELETE`) 시 문제가 발생한다
	- 삽입 이상
	- 갱신 이상
	- 삭제 이상

## 정규화 하는 법

### 제1정규형
- 테이블의 모든 열이 원자적인 값을 가지기
- `Hobbies` 테이블의 열에 `bowling, coding` 처럼 여러 값이 들어가면 안된다

- `Hobby` 테이블을 만들고, `User` 테이블과 `Hobby` 테이블이 N:M 관계가 되도록 한다
### 제2정규형
- 모든 속성은 기본 키 전체에 종속되어야 하며, 기본 키의 일부에만 종속되어서는 안된다
- `수강성적` 테이블에 `(학생ID, 과목ID)` 가 기본 키이고 `(학생명, 성적)` 이 있다고 할 경우
- `성적` 은 `(학생ID, 과목ID)` 전체에 종속되지만
- `학생명` 은 `(학생ID, 과목ID)` 가 아닌 `학생ID` 에만 종속된다

- `학생` 테이블 과 `수강성적` 테이블로 분리하도록 한다

### 제3정규형
- 기본 키가 아닌 모든 속성 간에는 서로 종속 관계가 없어야 한다
- `학생` 테이블에 `(학생ID [Primary Key], 학생명, 학과명, 학과사무실_번호)` 가 있다고 할 경우
- `학생ID` 가 정해지면 `학과명` 도 정해진다
- `학과명` 이 정해지면 `학과사무실_번호` 도 정해진다
- 즉, `학생ID`  가 정해지면 `학과사무실_번호` 도 정해지는 이행적 종속 이 발생한다
- `학과사무실_번호` 가 기본키가 아닌 다른 속성에 종속된 모습이다

- `학생`, (`학생ID [PK]`, `학생명`, `학과명 [Foreign Key]`) 테이블과
  `학과`, (`학과명 [PK]`, `학과사무실_번호`) 테이블로 분리한다

### BCNF, 4NF, 5NF

추후 공부


# 스키마 구현
## SQL DDL, Data Definition Language
- `CREATE`, `ALTER`, `DROP` 명령어를 통해 스키마를 정의하고 수정한다

## 학과 구현해보기
- `Department`
- `Student` - `Department`, 1:N
- `Course`
- `Enrollment` - `Student`, N:M

```sql
CREATE TABLE Department (
	dept_id INT PRIMARY KEY AUTO_INCREMENT,
	dept_name VARCHAR(100) NOT NULL UNIQUE,
	office_tel VARCHAR(20)
);
```

```sql
CREATE TABLE Student (
	student_id INT PRIMARY KEY AUTO_INCREMENT,
	student_name VARCHAR(50) NOT NULL,
	
	dept_id INT,
	
	CONSTRAINT fk_student_department
		FOREIGN KEY (dept_id)
		REFERENCES Department (dept_id)
		ON DELETE SET NULL
);
```

- 학생은 특정 학과에 소속되어야한다. 즉, N:1 의 관계이다
- 따라서 제약 조건으로 외래키 `dept_id` 열을 지정하고 참조해야할 테이블 `Department` 의 기본키 `student_id` 를 선언한다
- `ON DELETE SET NULL` 은 `Department` 테이블에서 어떤 학과가 사라지면 해당 학과 소속이었던 학생들이 가지던 외래키 `dept_id` 가 `NULL` 로 자동 변경되는 옵션이다

### N:M 관계 해소하기
- N:M 관계는 꼭 해소해야하는가?
- YES, 뭐가 문제인지 알아보자
- 학생은 여러 과목을 수강할 수 있고, 과목은 여러 학생들에게 등록될 수 있다.
- 테이블은 쉽게 말해 2차원 표다. 행과 열만이 존재한다

```sql
CREATE TABLE Student (
	student_id INT PRIMARY KEY,
	student_name VARCHAR(50),
	attended_courses VARCHAR(255)
);
```
- `attended_courses` 는 수강 등록한 과목이다.
- 과목은 여러개의 값이 될 수 있지만?
- 이런 테이블로는 한 학생 당 하나의 과목 밖에 등록하지 못 한다
- `데이터베이스 개론, JDBC, 테크니컬 라이팅` 이런 식으로 우겨넣으면 '원자성' 을 위반하게 된다

```sql
CREATE TABLE Student (
	student_id INT PRIMARY KEY,
	student_name VARCHAR(50),
	course_id INT,
	FOREIGN KEY (course_id) REFERENCES Course(course_id)
);
```
- 혹시 외래키로 넣으면 해결 될까? `Course` 테이블의 ID 들을 참조하게 했다
- 여전히 학생 하나에 하나의 과목만 등록된다

- 결론
- RDBMS, 관계형 데이터베이스에는 N:M 관계를 두 개의 테이블 `Student`, `Course` 만으로 표현이 불가능하다

- '연결 테이블', `Junction Table` 도입을 통해 해결하자
- 사고과정
	1. N:M 관계를 식별했다.
	2. 연결 테이블 설정이 필요하다. 연결 테이블은 두 개체의 '관계' 자체를 표현할 테이블이다
	3. 연결 테이블은 두 개체를 연결하는게 목적이다. 예시의 경우 '어떤' 학생이 '어떤' 과목 을 수강하는지 알아야한다
	4. `Student` 테이블의 ID, `Course` 테이블의 ID 를 참조해야함을 알 수 있다


```sql
CREATE TABLE Course (
	course_id INT PRIMARY KEY AUTO_INCREMENT,
	course_name VARCHAR(100) NOT NULL UNIQUE,
	credits INT NOT NULL
);
```

```sql
CREATE TABLE Enrollment (
	student_id INT,
	course_id INT,
	grade VARCHAR(2),
	
	PRIMARY KEY (student_id, course_id),
	
	CONSTRAINT fk_enroll_student
		FOREIGN KEY (student_id) REFERENCES Student (student_id)
		ON DELETE CASCADE,
		
	CONSTRAINT fk_enroll_course
		FOREIGN KEY (course_id) REFERENCES Course (course_id)
		ON DELETE RESTRICT
);
```

- `Enrollment` 테이블의 PK 는 어떻게 결정되는가?
- `student_id` 가 PK 일까?
	- 아니다. 학생은 여러 과목을 듣기 때문에 유일한 식별자가 아니다
	- 1번 학생이 1번 과목, 1번 학생이 2번 과목, ...
- `course_id` 가 PK 일까?
	- 아니다. 과목은 여러 학생에게 들어지기 때문에 유일한 식별자가 아니다
	- 1번 과목이 1번 학생에게, 1번 과목이 2번 학생에게, ...
- `(student_id, course_id)` 두 열의 조합은?
	- 유일하다. `1번 학생이 1번 과목을 듣는다` 는 정보는 유일하게 식별된다
	- 복합 기본 키, `Composite Primary Key` 가 정답이 된다

- `grade` 를 살펴보자
- 성적은 어디에 들어가야 할까?
- 학생 테이블에 성적이 들어갈까?
	- 학생 입장에서는 과목마다 성적이 다르다
	- 성적이 학생 테이블에 들어가도 모든 성적 표현이 불가능하다
- 과목 테이블에 성적이 들어갈까?
	- 과목 입장에서는 학생마다 성적이 다르다
	- 마찬가지로 과목 테이블에서 성적 표현이 불가능하다
- 즉, 성적은 학생과 과목이 묶여서 취급될때 함께 다뤄질 수 있다
	- 바로 `Enrollment` 테이블이 제격이다


### 제약 조건
- DB에 저장되는 데이터의 무결성, 일관성을 보장하기 위해 DBMS 가 강제하는 모든 규칙

- `CREATE TABLE`
	- `PRIMARY KEY`, `NULL` 을 허용하지 않고 유일해야하는 값, 테이블 당 하나만 존재
	- `FOREIGN KEY`, 다른 테이블의 PK 혹은 UNIQUE 인 열을 참조해 테이블 간의 관계를 정의, 참조 무결성
	- `UNIQUE`, 중복된 값을 허용하지 않음, 학생 테이블의 이메일, 학번 등
	- `CHECK`, 데이터가 특정 조건을 만족하는지 체크, `age > 0`, `gender IN ('MALE', 'FEMALE')`
	- `NOT NULL`, `NULL` 금지

- `FOREIGN KEY`
	- `ON DELETE`, 부모 테이블의 행이 삭제될 때 자식 테이블의 행동 정의
	- `ON UPDATE`, 부모 테이블의 행의 기본 키 값이 수정될 때 자식 테이블의 행동 정의

- `CASCADE`, 부모 값이 삭제, 혹은 수정되면 자식 값도 같이 삭제, 수정
- `RESTRICT`, 참조하는 자식 행이 있으면 삭제, 수정을 거부
- `NO ACTION`, `RESTRICT` 와 동일
- `SET NULL`, 부모 행이 삭제, 수정되면 자식행을 `NULL` 로 설정
- `SET DEFAULT`, 부모 행 삭제, 수정 시 자식 행의 외래 키 열을 `DEFAULT` 값으로 설정