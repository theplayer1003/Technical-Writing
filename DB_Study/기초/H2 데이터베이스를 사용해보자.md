# H2 데이터베이스를 사용해보자

## MySQL 쓸건데 왜?
- 일단 MySQL 의 복잡한 세팅보다 당장 가볍게 설치해서 연습할 수 있는 점 때문에 '데이터베이스 학습' 에 바로 집중할 수 있게 해줄거라 생각한다
- 나는 프리코스에서 일부러 VO 를 안 쓰는 경험을 해봤고 이를 통해 VO가 있을 때와 없을 때의 차이점을 직접 느낄 수 있었다
- 단순히 VO 는 이러한 편리함이 있으니 만드는게 좋아요 하고 사용하는 것 보다 더 입체적인 학습이 가능하다고 느꼈고 이를 여기에도 적용해보고자 한다


## JDBC with H2DB

```java
public class Sample {  
  
    private static final String DB_URL = "jdbc:h2:file:./data/missiondb";  
    private static final String USER = "sa";  
    private static final String PASS = "";  
  
    public static void main(String[] args) {  
        /**  
         * Connection, 표준 인터페이스  
         * DriverManager 클래스가 getConnection 메서드를 통해 여러 드라이버들을 스캔하며,  
         * DB_URL 값인 jdbc:h2 를 처리할 수 있는 드라이버를 찾아냄  
         * H2 드라이버가 실제 DB와 연결하여 Connection 인터페이스의 구현체를 생성하고 반환  
         */  
        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {  
  
            System.out.println("H2 데이터베이스 연결 성공: " + conn);  
  
            /**  
             * conn, Connection 으로부터 SQL 전송 객체인 Statement(interface)를 생성  
             * SQL 쿼리를 DB에 전송하는데 샤용되는 컨테이너, 전송 객체를 획득  
             * Statement 는 '정적'인 SQL 쿼리에 사용된다  
             * .executeUpdate() 메서드는 DB로부터 상태를 변경하는 SQL을 실행한다  
             */  
            try (Statement stmt = conn.createStatement()) {  
                String createTableSql = "CREATE TABLE IF NOT EXISTS USERS " +  
                        "(id INT AUTO_INCREMENT PRIMARY KEY, " +  
                        " username VARCHAR(255) NOT NULL, " +  
                        " email VARCHAR(255))";  
  
                stmt.executeUpdate(createTableSql);  
                System.out.println("테이블 USERS 생성 쿼리 완료");  
            }  
  
            /**  
             * 마찬가지로 커넥션으로부터 SQL 전송 객체인 PreparedStatement 를 얻는다  
             * PreparedStatement 는 동적 파라미터 ? 를 포함하는 SQL 쿼리에 사용된다  
             * .executeUpdate() 메서드는 DB로부터 상태를 변경하는 SQL을 실행한다  
             */  
            String insertSql = "INSERT INTO USERS (username, email) VALUES (?, ?)";  
            try (PreparedStatement pstmt = conn.prepareStatement(insertSql)) {  
  
                pstmt.setString(1, "pobi");  
                pstmt.setString(2, "pobi@nate.com");  
                pstmt.executeUpdate();  
  
                pstmt.setString(1, "james");  
                pstmt.setString(2, "james@budybudy.com");  
                pstmt.executeUpdate();  
  
                System.out.println("데이터 2건 삽입 완료");  
            }  
  
            /**  
             * .executeQuery() 메서드는 DB로부터 조회를 수행하는 SQL을 실행한다  
             * ResultSet 을 받아 순회하면서 내용을 출력  
             */  
            String staticSelectSql = "SELECT * FROM USERS";  
            try (Statement stmt = conn.createStatement();  
                 ResultSet rs = stmt.executeQuery(staticSelectSql)) {  
  
                System.out.println("\n-- USERS 테이블 데이터 조회 --");  
                while (rs.next()) {  
                    System.out.printf("ID: %d, Username: %s, Email: %s\n",  
                            rs.getInt("id"),  
                            rs.getString("username"),  
                            rs.getString("email")  
                    );  
                }  
            }  
  
            /**  
             * 동적인 쿼리 실행  
             * tragetUserId 라는 동적인 부분을 쿼리의 ?(placeholder) 에 추가  
             * setInt 메서드를 통해 플레이스홀더에 값을 바인딩  
             * 동적 쿼리에서는 쿼리를 인자로 넘기지 않고 그냥 executeQuery() 호출, 이미 PreparedStatement 가 쿼리를 가지고 있기 때문  
             * ResultSet 을 받아 순회하면서 내용을 출력  
             */  
            String dynamicSelectSql = "SELECT * FROM USERS WHERE id = ?";  
            int targetUserId = 2;  
            try (PreparedStatement pstmt = conn.prepareStatement(dynamicSelectSql)) {  
                pstmt.setInt(1, targetUserId);  
  
                try (ResultSet rs = pstmt.executeQuery()) {  
                    if (rs.next()) {  
                        System.out.println("\n-- ID가 " + targetUserId + "인 사용자 조회 --");  
                        System.out.printf("ID: %d, Username: %s, Email: %s\n",  
                                rs.getInt("id"),  
                                rs.getString("username"),  
                                rs.getString("email")  
                        );  
                    } else {  
                        System.out.println("ID가 " + targetUserId + "인 사용자를 찾을 수 없습니다");  
                    }  
                }  
            }  
  
        } catch (SQLException e) {  
            System.err.println("데이터베이스 연결 또는 쿼리 실행 중 오류 발생");  
            e.printStackTrace();  
        }  
    }  
}
```

### try-with-resources

```java
try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {
	...
} catch (SQLException e) {
	...
}
```

- JDBC 에서 사용되는 자원들은 컴퓨팅 리소스를 점유한다
- 따라서 사용 후 반납 절차가 있어야 하는데 이를 명시적으로 호출 해제 하기 시작하면 `finally` 구문에서 해제 코드가 끝도 없이 늘어날 수 있다
- JDBC의 인터페이스들은 `AutoCloseable` 을 구현하고 있으며 이를 통해 `try-with-resources` 구문에서 자동으로 자원을 반납할 수 있게 된다

- 이 구문의 핵심 기능 중 하나는 `Suppressed Exceptions` 이다
- 기존의 `try-finally` 에서는 `try` 블록에서 발생한 예외를 시작으로 `finally` 구문에 들어가 자원을 해제하려고 할 것이다
- 이때 자원 해제 과정에서 또 다른 예외가 발생한다면?
- 해당 메서드는 최종 발생한 예외를 밖으로 던지고 원본 예외는 사라져 버린다

- `try-with-resources` 를 사용하게 되면 이 문제가 해결된다
- `try` 블록의 예외 발생 후 자동 생성된 `finally` 블록에서 `close()` 호출로 자원을 해제한다
- 만약 해제 중 예외가 발생하면 원본 예외를 던지는데 그 안에 '억제된 예외' 목록을 같이 담아 던지도록 한다 (`Throwable.addSuppressed(Throwable)`)
- 이를 통해 발생한 두 예외를 모두 놓치지 않고 확인 가능하다

### JDBC
- Java 애플리케이션이 다양한 종류의 DB와 통신할 수 있도록 표준적인 통신 규약을 정의한 인터페이스, `Write once, run anywhere`
- JDBC 드라이버란 정의된 통신 규약에 맞춰 각 DB 가 제공해주는 구현체이다
- 즉, H2 DB가 Java가 정의한 규약에 맞춰 자신들의 DB를 사용 가능하도록 드라이버를 작성해서 제공해주는 것이다

### 몇 가지 시나리오 정리

#### 데이터를 조회할 때
- `SELECT` 쿼리를 실행하고 싶다면
- `Connection` 에서 받아온
	- `Statement`  를 통해 정적인 쿼리 처리
	- `PreparedStatement`  를 통해 동적인 쿼리 처리
		- 동적 처리의 경우 `set...` 메서드를 통해 플레이스홀더 값 바인딩
- `Statement` 에서 `ResultSet` 객체를 받아 데이터 접근

#### 데이터를 변경할 때
- `INSERT, UPDATE, DELETE` 쿼리를 처리하고 싶다면
- `Connection` 에서 받아온
- `PreparedStatement` 를 통해 `set...` 메서드로 플레이스홀더 바인딩
- `executeUpdate()` 메서드로 반영



## SQL Injection

```java
public class SqlInjectionSample {  
  
    private static final String DB_URL = "jdbc:h2:file:./data/practicedb_sqlinjection";  
    private static final String USER = "sa";  
    private static final String PASS = "";  
  
    public static void main(String[] args) {  
        setupDatabase();  
  
        String normalUserId = "james";  
        String attackPasswordInput = "' OR '1'='1";  
  
        System.out.println("\n-- [Statement] 를 사용한 취약한 로그인 시도 --");  
        stateSqlInjection(normalUserId, attackPasswordInput);  
  
        System.out.println("\n-- [PreparedStatement] 를 사용한 안전한 로그인 시도 --");  
        preparedSqlInjection(normalUserId, attackPasswordInput);  
    }  
  
    /**  
     * Statement 는 단순히 문자열을 합쳐서 쿼리를 실행한다  
     * 따라서 쿼리의 구조에 따라 의도하지 않은 값이 생성될 수 있다  
     * SELECT * FROM USERS WHERE username = 'james' AND password = '' OR '1'='1'  
     * 완성된 쿼리는 OR 문으로 인해 비밀번호 없이 참이 되어 로그인에 성공하게 된다  
     */  
    private static void stateSqlInjection(String normalUserId, String attackPasswordInput) {  
        String staticSql =  
                "SELECT * FROM USERS WHERE username = '" + normalUserId + "' AND password = '" + attackPasswordInput  
                        + "'";  
  
        System.out.println("[공격 쿼리]: " + staticSql);  
  
        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);  
             Statement stmt = conn.createStatement();  
             ResultSet rs = stmt.executeQuery(staticSql)) {  
  
            if (rs.next()) {  
                System.out.println("[결과] 로그인 성공 (ID: " + rs.getString("username") + ") - injection 성공");  
            } else {  
                System.out.println("[결과] 로그인 실패 - injection 실패");  
            }  
        } catch (SQLException e) {  
            System.err.println("[Error] " + e.getMessage());  
        }  
    }  
  
    /**  
     * PreparedStatement 는 conn.prepareStatement(sql) 시점에 쿼리를 먼저 컴파일 한다  
     * 이후 set... 메서드를 통해 플레이스홀드 값을 알맞게 세팅하게 되는데,  
     * JDBC 드라이버와 DB는 이미 쿼리의 틀 자체가 컴파일되어 있기 때문에 비밀번호 부분을 SQL 명령어가 아닌 문자열 값으로만 취급한다  
     * password 가 ' OR '1'='1 인 사용자가 없기 때문에 이 로그인은 실패로 끝난다  
     */  
    private static void preparedSqlInjection(String normalUserId, String attackPasswordInput) {  
        String dynamciSql = "SELECT * FROM USERS WHERE username = ? AND password = ?";  
  
        System.out.println("[동적 쿼리]: " + dynamciSql);  
  
        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);  
             PreparedStatement pstmt = conn.prepareStatement(dynamciSql)) {  
            pstmt.setString(1, normalUserId);  
            pstmt.setString(2, attackPasswordInput);  
  
            try (ResultSet rs = pstmt.executeQuery()) {  
                if (rs.next()) {  
                    System.out.println("[결과] 로그인 성공 (ID: " + rs.getString("username") + ")");  
                } else {  
                    System.out.println("[결과] 로그인 실패 - injection 방어");  
                }  
            }  
        } catch (SQLException e) {  
            System.err.println("[Error] " + e.getMessage());  
        }  
    }  
  
    /**  
     * Connection 을 열어 존재하던 테이블을 지우고,  
     * 테스트할 테이블을 생성한다  
     */  
    private static void setupDatabase() {  
        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);  
             Statement stmt = conn.createStatement()) {  
  
            stmt.executeUpdate("DROP TABLE IF EXISTS USERS");  
  
            stmt.executeUpdate("CREATE TABLE USERS (" +  
                    "id INT AUTO_INCREMENT PRIMARY KEY, " +  
                    "username VARCHAR(255) NOT NULL UNIQUE, " +  
                    "password VARCHAR(255) NOT NULL)");  
  
            stmt.executeUpdate("INSERT INTO USERS (username, password) VALUES ('james', 'james1234')");  
  
            System.out.println("-- 테스트 셋업 완료(james, james1234) --");  
  
        } catch (SQLException e) {  
            System.err.println("DB Set up Error: " + e.getMessage());  
            e.printStackTrace();  
        }  
    }  
}
```

- `Statement` 와 `PreparedStatement` 의 차이
- `Statement`
	- 문자열을 합치고 문자열을 이용해 쿼리를 실행
	- 따라서 악의적인 문자열이 들어올 경우 의도치 않은 작동 가능성이 있음
- `PreparedStatement`
	- 문자열 이전에 쿼리의 틀을 미리 컴파일 함
	- 이미 컴파일된 쿼리 안에 값만 문자열로서 취급되며 이를 SQL 명령어로 인식하지 않음

- 이러한 특성에 의해 JDBC에서는 조금이라도 동적인 값이 들어가는 쿼리가 있다면 무조건 `PreparedStatement` 를 사용해야한다



## 데이터 정합성, ACID, 트랜잭션

![[Mk2/2025woowa/precourse/week5/테크니컬_라이팅/DB_Study/기초/데이터 정합성, ACID, 트랜잭션]]


## 인터페이스 별 주요 책임과 메서드 정리

### Connection
- 데이터베이스와의 물리적 연결 인터페이스
- 모든 통신이 이 객체로 통한다
- 트랜잭션 관리의 주체다
- 쿼리 실행을 위한 `...Statment` 객체 생성, 팩토리 역할을 담당한다

- `createStatement()` : 정적 SQL 을 위한 `Statement` 객체 생성
- `prepareStatement()` : 동적 SQL 을 위한 `PreparedStatement` 객체 생성
- `setAutoCommit(boolean)` : 트랜잭션 모드, false 로 해서 수동으로 커밋, 롤백 등을 개발자가 조정한다
- `commit(), rollback()`  : 커밋, 롤백
- `close()` : 연결을 끊고 자원 반납

### Statement
- 정적 SQL 처리를 위한 컨테이너
- SQL Injection으로 사실상 안 쓴다고 봐도 좋다
- `PreparedStatement` 에 비해 딱히 성능이 더 좋은 것도 아니다
- 사실상 JDBC 1.0 시절의 유물급, SQL Injection 시연할 때만 사용한다

- `ResultSet executeQuery(String sql)` : `SELECT` 쿼리 실행, 결과로 `ResultSet` 반환
- `int executeUpdate(String sql)` : `INSERT`, `UPDATE`, `DELETE` 쿼리 실행, 영향받은 행의 개수를 반환
- `void close()` : 자원 반납

### PreparedStatement
- 동적 SQL 처리를 위한 컨테이너
- SQL 쿼리의 틀과 값을 분리해 Injection 공격을 방지한다
- 쿼리가 미리 컴파일되는 특성으로 동일 쿼리 반복 시 `Statement` 보다 성능 이점이 있다

- `void set...(int parameterIndex, ... value)`
플레이스홀더에 값을 바인딩한다. `parameterIndex` 는 1 부터 시작
- `ResultSet executeQuery()` : 인자 없이 미리 세팅된 `SELECT` 쿼리를 실행한다
- `int executeUpdate()` : 인자 없이 미리 세팅된 `INSERT`, `UPDATE`, `DELETE`, `CREATE`, `DROP` 쿼리를 실행한다. 반환 값으로 영향을 받은 행의 수를 반환한다
- `void close()` : 자원 반납

### ResultSet
- 결과 데이터 집합을 담고 있는 객체
- `executeQuery()` 로 얻을 수 있다
- 데이터 뿐만 아니라 컬럼명, 컬럼 타입 등 메타데이터도 가지고 있다
- 내부에 커서가 구현되어 있어 한 번에 한 행만 가리킨다

- `boolean next()` : 다음 행으로 이동, 이동 가능하면 `true`, 그렇지 않으면 `false`
```
while (rs.next()) { ... } : 표준 순회법

SELECT 후 데이터를 읽기 전에 반드시 rs.next() 가 한번 호출되어야 한다
초기 커서값은 1행 이전을 가리키고 있는 상태다
```
- `... get...(String columnName)` : 현재 커서가 가리키는 행에서 컬럼명을 통해 ... 타입으로 가져온다
- `... get...(int columnIndex)` : 컬럼명 대신 컬럼의 순서를 통해 값을 가져온다. 테이블 변경 등의 경우 유지보수에 취약하다. 컬럼명을 통한 조회만 사용하자
- `void close()` : 자원 반납



## 성능 및 리소스 관리

![[Mk2/2025woowa/precourse/week5/테크니컬_라이팅/DB_Study/기초/성능 및 리소스 관리, Connection Pool]]


